сделано дерево самостроящееся

00.
001. сделать PERFORM вызов ХП с двумя параметрами на двух строчках их ХП
002. проверить на PG 8-4 - работает ли вызов
003. сделать класс расширяющий PgSqlIncludeListener куда перенести весь важный код, а в PgSqlIncludeListener пометить методы как абстрактыне
цель - убрать сахарный код с глаз долой
004.
 -- ввести IN OUT INOUT VARIADIC DEFAULT
 -- окружить тестами

 -- вытащить инфу по типу возврата
 -- вытащить инфу по параметрам (в т.ч. по IN/OUT)
 -- всю инфу сложить в спец объект

004-02
 -- пишем тест для p02_void_perform.sql - читаем все ф-ции участвующие в этом вызове
 -- сохдаеим дерево вызовов - провреяем визуально
 --  пишем первый вариант генерации с тупой вставко всего тела ф-ции
     -- тело ф-ции надо положить в PgDefined -> inputStream выкачать в массив, из массива сделать String и CharStream,
         String (тело ф-ции положить в PgDefined)

 -- вызываемые ф-ции сравнивать на нахождение в этом списке
 -- вытащить инфу по строке/позиции начала и конца вызова и записать в pgResult
 -- не найденные - это ошибка - нужен тест на этот вариант

005. написать скелет кода по вставке ХП в родительскую ХП

0. переписать пул потоков с учетом документа Пропроцессор PG Antrl4

куск дерева можно создавать только с двумя уровнями или с одним
т.к. PG может вызвать другое PG и на этом все - т.е. 2 уровня

1. обложить тестами и проверить вставку поддерева в конец и в середину, проверить на ошибки вставки
(если вдруг у замещаемого нода есть дети - то тогда д.б. исключение)

2. для визуализации верности замещения в PgTreeNode надо заюзать invokeInfo
ыфыести важну. часть invokeInfo в drawTree
в него положить тип PG вызова (например PERFORM и т.п.)
чтобы было видно все ли верно замещается, не перетирается ли эта инфа

3. drawTree писать в строку, выводить в консоль
а в итоге результат положить в MD5 и потом в тестах сравнивать

4. затем перейти к реальным тестам с PgParsingResult
****помнить что надо ввести сранение по типу возврата ф-ции и по сигнатуре ф-ции
